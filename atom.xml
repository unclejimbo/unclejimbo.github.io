<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>unclejimbo&#39;s site</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unclejimbo.github.io/"/>
  <updated>2017-06-18T10:08:19.050Z</updated>
  <id>https://unclejimbo.github.io/</id>
  
  <author>
    <name>unclejimbo (王少东)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mesh Processing with CGAL</title>
    <link href="https://unclejimbo.github.io/2017/06/14/Mesh-Processing-with-CGAL/"/>
    <id>https://unclejimbo.github.io/2017/06/14/Mesh-Processing-with-CGAL/</id>
    <published>2017-06-14T13:24:34.000Z</published>
    <updated>2017-06-18T10:08:19.050Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cgal.org/index.html" target="_blank" rel="external">CGAL</a>, which stands for the Computational Geometry Algorithms Library, is an important tool set to use and build geometric algorithms. It contains a tons of packages with various functionalities, so this time I’m only gonna explore a little part of this beast and figure out the basics to do mesh processing with CGAL.</p>
<p><img src="http://doc.cgal.org/latest/Surface_mesh_simplification/Illustration-Simplification-ALL.jpg" alt=""><br>(<em>Mesh smoothing algorithm, picture taken from the <a href="http://doc.cgal.org/latest/Surface_mesh_simplification/index.html#Chapter_Triangulated_Surface_Mesh_Simplification" target="_blank" rel="external">CGAL document</a></em>).</p>
<a id="more"></a>
<h1 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h1><p>First of all, I assume you already know the basics of mesh processing, especially the halfedge data structure, because all the related packages and algorithms in CGAL are implemented upon this data structure. If you don’t, <a href="https://www.openmesh.org/Daily-Builds/Doc/a00016.html" target="_blank" rel="external">here</a> is a concise introduction or you can resort to the <a href="http://www.pmp-book.org/" target="_blank" rel="external">PMP</a> book for a more comprehensive treatment.</p>
<p>And I also assume you have installed CGAL properly and run through the <a href="http://doc.cgal.org/latest/Manual/tutorial_hello_world.html" target="_blank" rel="external">hello world</a> tutorial if you haven’t used this library before.</p>
<p>Note that the stable release version of CGAL at the time of writing is 4.10.</p>
<h1 id="The-Polyhedron-3-Package"><a href="#The-Polyhedron-3-Package" class="headerlink" title="The Polyhedron_3 Package"></a>The Polyhedron_3 Package</h1><p>The <a href="http://doc.cgal.org/latest/Polyhedron/index.html#Chapter_3D_Polyhedral_Surfaces" target="_blank" rel="external">3D Polyhedral Surface</a> package, or Polyhedron_3 as its name in the program, is a pointer-based implementation of the halfedge data structure released since the 1.0 version of CGAL.</p>
<h2 id="Creation"><a href="#Creation" class="headerlink" title="Creation"></a>Creation</h2><p>There are convinient functions to create a tetrahedron though they are not very useful.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Traits &gt;</div><div class="line">Halfedge_handle CGAL::Polyhedron_3&lt; Traits &gt;::make_tetrahedron();</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Traits &gt;</div><div class="line">Halfedge_handle CGAL::Polyhedron_3&lt; Traits &gt;::make_tetrahedron(</div><div class="line">    <span class="keyword">const</span> Point&amp; p1,</div><div class="line">    <span class="keyword">const</span> Point&amp; p2,</div><div class="line">    <span class="keyword">const</span> Point&amp; p3,</div><div class="line">    <span class="keyword">const</span> Point&amp; p4 </div><div class="line">);</div></pre></td></tr></table></figure>
<p>You can also read from a file, which is what we usually need in practice. Although it only support very few common file formats like off and obj. You can also write out Polyhedron_3 to a file.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CGAL/IO/Polyhedron_iostream.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolyhedronTraits_3&gt;</div><div class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;( ostream&amp; out, </div><div class="line"><span class="keyword">const</span> CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;&amp; P);</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PolyhedronTraits_3&gt;</div><div class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;( istream&amp; in, </div><div class="line">CGAL::Polyhedron_3&lt;PolyhedronTraits_3&gt;&amp; P);</div></pre></td></tr></table></figure>
<p>When you need to read some other file formats not supported by this package, or to build the mesh procedurally, then you should use the incremental builder. The following example shows how to build up a Polyhedron_3 mesh from a list of veritices and indices.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CGAL/Simple_cartesian.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CGAL/Polyhedron_3.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CGAL/Polyhedron_incremental_builder_3.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Polyhedron_3&gt;</div><div class="line"><span class="keyword">class</span> TriMeshBuilder : <span class="keyword">public</span> CGAL::Modifier_base&lt;<span class="keyword">typename</span> Polyhedron_3::HalfedgeDS&gt;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">using</span> FT = <span class="keyword">typename</span> Polyhedron_3::Traits::Kernel::FT;</div><div class="line">    <span class="keyword">using</span> HDS = <span class="keyword">typename</span> Polyhedron_3::HalfedgeDS;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    TriMeshBuilder(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FT&gt;&amp; vertices, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt;&amp; indices)</div><div class="line">        : _vertices(vertices), _indices(indices)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(HDS&amp; hds)</span></span></div><div class="line">    &#123;</div><div class="line">        CGAL::Polyhedron_incremental_builder_3&lt;HDS&gt; builder(hds, <span class="literal">true</span>);</div><div class="line">        builder.begin_surface(_vertices.size(), _indices.size() / <span class="number">3</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; _vertices.size(); i += <span class="number">3</span>) &#123;</div><div class="line">            builder.add_vertex(HDS::Vertex::Point(</div><div class="line">                _vertices[i], _vertices[i + <span class="number">1</span>], _vertices[i + <span class="number">2</span>]));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; _indices.size(); ++i) &#123;</div><div class="line">            builder.begin_facet();</div><div class="line">            builder.add_vertex_to_facet(_indices[i++]);</div><div class="line">            builder.add_vertex_to_facet(_indices[i++]);</div><div class="line">            builder.add_vertex_to_facet(_indices[i]);</div><div class="line">            builder.end_facet();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        builder.end_surface();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FT&gt; _vertices;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; _indices;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = CGAL::Simple_cartesian&lt;<span class="keyword">float</span>&gt;;</div><div class="line"><span class="keyword">using</span> FT = Kernel::FT;</div><div class="line"><span class="keyword">using</span> Polyhedron_3 = CGAL::Polyhedron_3&lt;Kernel&gt;;</div><div class="line"><span class="keyword">using</span> HDS = Polyhedron_3::HalfedgeDS;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FT&gt; vertices;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; indices;</div><div class="line">    <span class="comment">// Fill in the data...</span></div><div class="line">    Polyhedron_3 P;</div><div class="line">    TriMeshBuilder&lt;HDS&gt; builder(vertices, indices);</div><div class="line">    P.delegate(builder);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h2><p>The key feature of a halfedge data structure is its flexibility to navigate on the mesh.</p>
<p>There are iterators you can use to iterate through vertices, halfedges, edges and facets. Keep in mind that when you dereference a iterator you’ll get the corresponding handle type. Their documentation is a bit of frustrating.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">Vertex_iterator <span class="title">vertices_begin</span><span class="params">()</span></span>;</div><div class="line"><span class="function">Vertix_iterator <span class="title">vertices_end</span><span class="params">()</span></span>;</div><div class="line"><span class="function">Facet_iterator <span class="title">facets_begin</span><span class="params">()</span></span>;</div><div class="line"><span class="function">Facet_iterator <span class="title">facets_end</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">// etc</span></div></pre></td></tr></table></figure>
<p>There is also a special type of iterator called the circulator, who can iterate around a target primitive. Note that the below functions are accessed from a handle, and return a halfedge handle from which the desired primitive can be resolved.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Iterate around all the vertices of a facet,</span></div><div class="line"><span class="function">Halfedge_around_facet_circulator <span class="title">facet_begin</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">// Iterate around all the vertices incident of a vertex</span></div><div class="line"><span class="function">Halfedge_around_vertex_circulator <span class="title">vertex_begin</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>Let’s see a concrete example to compute the valence of a mesh, I’m only showing the key part.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    Polyhedron_3 P;</div><div class="line">    <span class="keyword">for</span> (Vertex_iterator vit = P.vertices_begin(); vit != P.vertices_end(); ++vit) &#123;</div><div class="line">        <span class="keyword">auto</span> valence = <span class="number">0</span>;</div><div class="line">        Halfedge_around_vertex_circulator vcir = vit-&gt;vertex_begin();</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            ++valence;</div><div class="line">        &#125; <span class="keyword">while</span>(++vcir != vit-&gt;vertex_begin());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="The-Surface-mesh-Package"><a href="#The-Surface-mesh-Package" class="headerlink" title="The Surface_mesh Package"></a>The Surface_mesh Package</h1><p>Since version 4.6, CGAL introduces a new <a href="http://doc.cgal.org/latest/Surface_mesh/index.html#sectionSurfaceMeshUsage" target="_blank" rel="external">Surface Mesh</a> package to replace the old Polyhedron_3 package. So why do we need another halfedge data structure? This <a href="http://imr.sandia.gov/papers/imr20/Sieger.pdf" target="_blank" rel="external">benchmark</a> shows that the Surface_mesh package achieves better runtime speed with less memory footprints. The reason behind this achievement is because this new package uses an index-based approach to store the mesh, rather than the pointer-based approach taken by Polyhedron_3. So it is recommended to use this package as your first choice. Although at the time of writing there are a few packages in CGAL who still don’t support Surface_mesh, so you may want to resort to Polyhedron_3 in such a situation.</p>
<p>The official examples and documentations for this package are much more well-organized. With the experience you already gained from Polyhedron_3, I’m sure you could head directly to the manual and learn how to use this package by yourself.</p>
<h1 id="Let’s-Be-More-Generic"><a href="#Let’s-Be-More-Generic" class="headerlink" title="Let’s Be More Generic"></a>Let’s Be More Generic</h1><p>From this point on, you already have enough ground to use the mesh data structures. So you could head towards to the specific mesh processing algorithm you need to use. There are quite a few packages out there, including Polygon_mesh_processing, Subdivision, Segmentation, just to name a few. But if you need to use the halfedge data structures provided by CGAL and implement your own mesh processing algorithms on top of that, then you might want to learn more on how to do this effectively.</p>
<p>If you go to check those algorithmic packages and you’ll find out that most of them support both Polyhedron_3 and Surface_mesh using the same interface. How to achieve that? Do we have to manually convert one data structure to another? Or do we have to specialize every algorithm for these two data structures? The way CGAL deals with different halfedge implementations is through concepts and traits.</p>
<p>Manifold surface meshes are in essence graphs, so CGAL defines several <a href="http://doc.cgal.org/latest/BGL/group__PkgBGLConcepts.html" target="_blank" rel="external">graph concepts</a> to abstract away the behaviour a halfedge data structure should abide. By parameterizing the mesh data type using template and programming against the graph concepts, any implementation that meets the definition of those concepts can be used by the algorithm.</p>
<p>In order to transform the interfaces of both data structures to conform to the interface required by the graph concepts, CGAL defines a lot of trait classes, which all reside in the “CGAL/boost/graph” directory. Except for Polyhedron_3 and Surface_mesh, a lot of other data structures in CGAL could also use traits to conform to the graph concepts so as to be used by the algorithms. There is even a trait class for <a href="https://www.openmesh.org/" target="_blank" rel="external">OpenMesh</a>, which is also a popular choice of halfedge implementation, defined in the file “graph_traits_TriMesh_ArrayKernelT.h”. In other words, all the algorithms written against the graph concepts could also operate on OpenMesh.</p>
<p>That’s how generic programming saves the world. In fact, the graph concepts defined by CGAL actually conform to the API defined by <a href="http://www.boost.org/doc/libs/1_64_0/libs/graph/doc/" target="_blank" rel="external">BGL</a>, a general graph library, so some basic graph algorithms like shortest path or minimum spanning tree could also operate on Polyhedron_3 and Surface_mesh. As a result, as long as you write your own algorithm using the interface defined by the graph concepts, a lot of data structures could be used with only one implementation. Awesome.</p>
<h2 id="Let’s-Be-More-Concrete"><a href="#Let’s-Be-More-Concrete" class="headerlink" title="Let’s Be More Concrete"></a>Let’s Be More Concrete</h2><p>Now I’ll show you one concrete example on how this thing works. Why don’t we just checkout the mesh fairing function from the <a href="http://doc.cgal.org/latest/Polygon_mesh_processing/group__PMP__meshing__grp.html#gaa091c8368920920eed87784107d68ecf" target="_blank" rel="external">Polygon Mesh Processing</a> package.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TriangleMesh, <span class="keyword">typename</span> VertexRange, <span class="keyword">typename</span> NamedParameters&gt;</div><div class="line"><span class="keyword">bool</span> CGAL::Polygon_mesh_processing::fair(</div><div class="line">    TriangleMesh&amp; tmesh,</div><div class="line">    <span class="keyword">const</span> VertexRange&amp; vertices,</div><div class="line">    <span class="keyword">const</span> NamedParameters&amp; np </div><div class="line">)</div></pre></td></tr></table></figure>
<p>This function takes in a mesh and range of vertices you want to fair, and smoothes out the mesh as much as possible. The np parameter is not important here. So how does CGAL make this function work on all the data structure? We should look into the source code in file “CGAL\Polygon_mesh_processing\internal\fair_impl.h” to see what happens.</p>
<p>We could see that the algorithm is implemented with the graph concept api rather than any class-specific interface. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//...</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;PolygonMesh&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="comment">//...</span></div><div class="line">vertex_descriptor nv = target(opposite(*circ,pmesh),pmesh);</div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure>
<p>And the real implementations for these apis are actually template specializations for each known data structure defined in the trait classes I mentioned earlier. You could check the implementation of Polyhedron_3 for example in “CGAL/boost/graph/graph_traits_Polyhedron_3.h”.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//...</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Gt, <span class="keyword">class</span> I, CGAL_HDS_PARAM_, <span class="keyword">class</span> A&gt;</div><div class="line"><span class="keyword">struct</span> graph_traits&lt; CGAL::Polyhedron_3&lt;Gt,I,HDS,A&gt; &gt;</div><div class="line">   : CGAL::HDS_graph_traits&lt; CGAL::Polyhedron_3&lt;Gt,I,HDS,A&gt; &gt;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Gt::Point_3 vertex_property_type;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Gt, <span class="keyword">class</span> I, CGAL_HDS_PARAM_, <span class="keyword">class</span> A&gt;</div><div class="line"><span class="keyword">typename</span> boost::graph_traits&lt; CGAL::Polyhedron_3&lt;Gt,I,HDS,A&gt; <span class="keyword">const</span>&gt;::<span class="function">vertex_descriptor</span></div><div class="line"><span class="title">target</span><span class="params">(<span class="keyword">typename</span> boost::graph_traits&lt; CGAL::Polyhedron_3&lt;Gt,I,HDS,A&gt; <span class="keyword">const</span>&gt;::edge_descriptor e</span></div><div class="line">       , <span class="keyword">const</span> CGAL::Polyhedron_3&lt;Gt,I,HDS,A&gt; &amp; )</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> e.halfedge()-&gt;vertex();</div><div class="line">&#125;</div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Gt, <span class="keyword">class</span> I, CGAL_HDS_PARAM_, <span class="keyword">class</span> A&gt;</div><div class="line"><span class="keyword">typename</span> boost::graph_traits&lt; CGAL::Polyhedron_3&lt;Gt,I,HDS,A&gt; &gt;::<span class="function">halfedge_descriptor</span></div><div class="line"><span class="title">opposite</span><span class="params">(<span class="keyword">typename</span> boost::graph_traits&lt; CGAL::Polyhedron_3&lt;Gt,I,HDS,A&gt; &gt;::halfedge_descriptor h</span></div><div class="line">         , <span class="keyword">const</span> CGAL::Polyhedron_3&lt;Gt,I,HDS,A&gt;&amp;)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> h-&gt;opposite();</div><div class="line">&#125;</div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure>
<p>In this way, the compiler will automatically use the right specialization for a data structure to use. This is often called static dispatch.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>I hope that I have sorted out some of the mess about using this library. You may also be interested in reading the <a href="http://doc.cgal.org/latest/BGL/index.html#Chapter_CGAL_and_the_Boost_Graph_Library" target="_blank" rel="external">BGL package</a> and <a href="http://doc.cgal.org/latest/Property_map/index.html#Chapter_CGAL_and_Boost_Property_Maps" target="_blank" rel="external">Boost PropertyMap package</a> for further information.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cgal.org/index.html&quot;&gt;CGAL&lt;/a&gt;, which stands for the Computational Geometry Algorithms Library, is an important tool set to use and build geometric algorithms. It contains a tons of packages with various functionalities, so this time I’m only gonna explore a little part of this beast and figure out the basics to do mesh processing with CGAL.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://doc.cgal.org/latest/Surface_mesh_simplification/Illustration-Simplification-ALL.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;(&lt;em&gt;Mesh smoothing algorithm, picture taken from the &lt;a href=&quot;http://doc.cgal.org/latest/Surface_mesh_simplification/index.html#Chapter_Triangulated_Surface_Mesh_Simplification&quot;&gt;CGAL document&lt;/a&gt;&lt;/em&gt;).&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Graphics" scheme="https://unclejimbo.github.io/categories/Computer-Graphics/"/>
    
    
      <category term="Computer Graphics" scheme="https://unclejimbo.github.io/tags/Computer-Graphics/"/>
    
      <category term="CGAL" scheme="https://unclejimbo.github.io/tags/CGAL/"/>
    
      <category term="Geometry Processing" scheme="https://unclejimbo.github.io/tags/Geometry-Processing/"/>
    
  </entry>
  
  <entry>
    <title>Looping Performance in C++</title>
    <link href="https://unclejimbo.github.io/2017/04/03/Looping-Performance-in-C++/"/>
    <id>https://unclejimbo.github.io/2017/04/03/Looping-Performance-in-C++/</id>
    <published>2017-04-03T19:21:00.000Z</published>
    <updated>2017-04-03T19:54:44.524Z</updated>
    
    <content type="html"><![CDATA[<p>Today I was testing the performance of a piece of code, which is basically accessing each element in a container within a for loop. But the result is quite shocking because I found the std::for_each version is 10 times faster than the raw loop. What?</p>
<a id="more"></a>
<h1 id="Test-for-yourself"><a href="#Test-for-yourself" class="headerlink" title="Test for yourself"></a>Test for yourself</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, 6&gt; buffers;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</div><div class="line">		buffers[i] = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">480000</span>, <span class="number">0.5f</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">auto</span> tstart = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</div><div class="line">	<span class="keyword">auto</span> accum = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; buffers[i].size(); ++j) &#123;</div><div class="line">			<span class="keyword">if</span> (buffers[i][j] &lt; <span class="number">1.0f</span>)</div><div class="line">				++accum;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">auto</span> tend = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</div><div class="line">	<span class="keyword">auto</span> duration = tend - tstart;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Raw loop: "</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;(duration).count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	tstart = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</div><div class="line">	accum = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; buffer : buffers) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; value : buffer) &#123;</div><div class="line">			<span class="keyword">if</span> (value &lt; <span class="number">1.0f</span>)</div><div class="line">				++accum;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	tend = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</div><div class="line">	duration = tend - tstart;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"Range-based for loop: "</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;(duration).count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	tstart = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</div><div class="line">	accum = <span class="number">0</span>;</div><div class="line">	<span class="built_in">std</span>::for_each(buffers.begin(), buffers.end(),</div><div class="line">		[&amp;accum](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&amp; buffer) &#123;</div><div class="line">			<span class="built_in">std</span>::for_each(buffer.begin(), buffer.end(), [&amp;accum](<span class="keyword">float</span> value) &#123; <span class="keyword">if</span> (value &lt; <span class="number">1.0f</span>) ++accum; &#125;);</div><div class="line">		&#125;</div><div class="line">	);</div><div class="line">	tend = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</div><div class="line">	duration = tend - tstart;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::for_each: "</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;(duration).count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>I was using VS2015 under Debug build. Here’s the output:</p>
<blockquote>
<p>Raw loop: 978</p>
<p>Range-based for loop: 426</p>
<p>std::for_each: 66</p>
</blockquote>
<p>However when I switched to Release build:</p>
<blockquote>
<p>Raw loop: 2</p>
<p>Range-based for loop: 2</p>
<p>std::for_each: 5</p>
</blockquote>
<p>That’s what I’ve been expecting. And when I changed time precision to nanoseconds it turned out that raw loop is slightly faster than the range-based for loop.</p>
<h1 id="Lesson-learned"><a href="#Lesson-learned" class="headerlink" title="Lesson learned"></a>Lesson learned</h1><p>The compiler sure knows how to optimize your code. So do your profiling with optimization on.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Today I was testing the performance of a piece of code, which is basically accessing each element in a container within a for loop. But the result is quite shocking because I found the std::for_each version is 10 times faster than the raw loop. What?&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://unclejimbo.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://unclejimbo.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>RTTI in C++</title>
    <link href="https://unclejimbo.github.io/2017/02/22/RTTI-in-C++/"/>
    <id>https://unclejimbo.github.io/2017/02/22/RTTI-in-C++/</id>
    <published>2017-02-22T18:30:37.000Z</published>
    <updated>2017-02-22T13:17:01.077Z</updated>
    
    <content type="html"><![CDATA[<p>RunTime Type Information or RunTime Type Identification, or just RTTI, is a useful feature in C++ language. As its name suggests, this facility gives you the ability to query type information at runtime.</p>
<ul>
<li><code>dynamic_cast&lt;&gt;</code></li>
<li><code>typeid()</code></li>
</ul>
<p>Those are the main tools to achieve RTTI. Some of you may frown upon this RTTI thing because it seems to have a bad reputation out there, and there is a good reason for that. Generally you want to stay away from this feature because static typing is much safer than dynamic typing thanks to the compiler, and it gives you runtime overheads as well. So why is it useful?</p>
<a id="more"></a>
<h1 id="Walking-around-the-Inheritance-Graph"><a href="#Walking-around-the-Inheritance-Graph" class="headerlink" title="Walking around the Inheritance Graph"></a>Walking around the Inheritance Graph</h1><p>Generally we use virtual inheritance and polymorphism because we only care about the interface but not the exact implementations. However, some derived classes may have specific method that doesn’t fit into the interface in any way. Although it is possible to add another virtual function to the base class and all its derived classes and let them provide empty implementations. But doesn’t that sounds awkward when you tell every Person class to program() when a Programmer class has to? It might be more reasonable to recover the true type (not exactly right with dynamic_cast&lt;&gt;, I’ll talk about it later) of a polymorphic type and call the class’s unique function as needed.</p>
<p><code>dynamic_cast&lt;&gt;</code> is your first choice to achieve this. Consider the following codes,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Base1</div><div class="line">&#123;</div><div class="line">  virtual void base1Fcn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Base2</div><div class="line">&#123;</div><div class="line">  virtual void base2Fcn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Derived : public Base1, public Base2</div><div class="line">&#123;</div><div class="line">  void base1Fcn() override;</div><div class="line">  void base2Fcn() override;</div><div class="line">  virtual void derivedFcn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// upcast, which is just good old polymorphic pointers</div><div class="line">Derived* pd = new Derived();</div><div class="line">Base1* pb1 = pd;</div><div class="line">Base2* pb2 = dynamic_cast&lt;Base2*&gt;(pd); // Same as above, no explicit cast needed</div><div class="line"></div><div class="line">// downcast, which casts base pointer to derived class</div><div class="line">Base1* pb1 = new Derived();</div><div class="line">Derived* pd = dynamic_cast&lt;Derived*&gt;(pb1);</div><div class="line"></div><div class="line">// crosscast, which casts from one base pointer to a sibling</div><div class="line">Base1* pb1 = new Derived();</div><div class="line">Base2* pb2 = dynamic_cast&lt;Base2*&gt;(pb1);</div></pre></td></tr></table></figure>
<p>As is quite clear in the codes and comments, you can use <code>dynamic_cast&lt;&gt;</code> to walk around the inheritance graph get to the specific class you need, as long as virtual inheritance is used. The name upcast, downcast, and crosscast come from the tradition to draw base class on top of the derived in an inheritance graph.</p>
<h1 id="Querying-the-Exact-Type"><a href="#Querying-the-Exact-Type" class="headerlink" title="Querying the Exact Type"></a>Querying the Exact Type</h1><p>Remember earlier I said that <code>dynamic_cast&lt;&gt;</code> isn’t really about recovering the true type of a polymorphic pointer. Let’s say we have another class down the inheritance graph,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class FurtherDerived : public Derived</div><div class="line">&#123;</div><div class="line">  void derivedFcn() override;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Base1* pb1 = new FurtherDerived();</div><div class="line">Derived* pd = dynamic_cast&lt;Derived*&gt;(pb1); // See? Derived is not the real type pb1 points to</div><div class="line">pd-&gt;derivedFc(); // But this will work</div></pre></td></tr></table></figure>
<p>Bjarne Stroustrup has made this quite clear in TCPL,</p>
<blockquote>
<p>From a design perspective, dynamic_cast can be seen as a mechanism for asking an object if it provides a given interface</p>
</blockquote>
<p>As long as the class provides the requested interface, <code>dynamic_cast&lt;&gt;</code> will work. In other words it works for all derived classes down the road. So how do we find out the exact type of an object? It’s <code>typeid()</code> to the rescue.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeid(*pb1) == typeid(FurtherDerived); // true</div><div class="line">typeid(*pb1) == typeid(Derived); // false</div></pre></td></tr></table></figure>
<p>The return type of <code>typeid()</code> is <code>std::type_info</code> which has some other useful functions like hashing and name string. Keep in mind that <code>typid()</code> and <code>dynamic_cast&lt;&gt;</code> are designed for different tasks so you shouldn’t misuse both.</p>
<h1 id="Alternatives"><a href="#Alternatives" class="headerlink" title="Alternatives"></a>Alternatives</h1><p>You could almost always redesign the inheritance relationships and use virtual functions to do dynamic dispatching. But do know that you have the right tools at hands and don’t hesitate to use them when needed.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RunTime Type Information or RunTime Type Identification, or just RTTI, is a useful feature in C++ language. As its name suggests, this facility gives you the ability to query type information at runtime.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typeid()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Those are the main tools to achieve RTTI. Some of you may frown upon this RTTI thing because it seems to have a bad reputation out there, and there is a good reason for that. Generally you want to stay away from this feature because static typing is much safer than dynamic typing thanks to the compiler, and it gives you runtime overheads as well. So why is it useful?&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://unclejimbo.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://unclejimbo.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Implementing MVCNN with Caffe, Part I</title>
    <link href="https://unclejimbo.github.io/2017/01/05/2017-1-5-Implementing-MVCNN-with-Caffe-Part-I/"/>
    <id>https://unclejimbo.github.io/2017/01/05/2017-1-5-Implementing-MVCNN-with-Caffe-Part-I/</id>
    <published>2017-01-05T00:00:00.000Z</published>
    <updated>2017-01-05T08:35:19.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This post is about a paper published in ICCV2015, called <a href="http://www.cv-foundation.org/openaccess/content_iccv_2015/papers/Su_Multi-View_Convolutional_Neural_ICCV_2015_paper.pdf" target="_blank" rel="external">“Multi-view Convolutional Neural Networks for 3D Shape Recognition”</a>. It describes a method to classify 3d shape models using 2d image classification networks. While the authors have open-sourced their matlab implementation on <a href="https://github.com/suhangpro/mvcnn" target="_blank" rel="external">GitHub</a>, here I’ll try to implement this network with Caffe.</p>
<p>In the first half of this two-part blog, I’ll quickly explain the core idea of this paper. After that I’ll try to implement a naive version of this network. While in part II I’ll go through the details on implementing MVCNN as the paper describes.</p>
<p>The complete codes and scripts in this blog can be found at my <a href="https://github.com/unclejimbo/mvcnn-caffe" target="_blank" rel="external">GitHub repo</a>.</p>
<p><img src="https://camo.githubusercontent.com/f505454fa4d971db8b85b35ad7cac63795d3eaa0/687474703a2f2f7669732d7777772e63732e756d6173732e6564752f6d76636e6e2f696d616765732f6d76636e6e2e706e67" alt=""><br>(<em>The network architecture of MVCNN</em>)</p>
<a id="more"></a>
<h1 id="The-Power-of-Multi-View"><a href="#The-Power-of-Multi-View" class="headerlink" title="The Power of Multi-View"></a>The Power of Multi-View</h1><p>Traditional 3d shape recognition algorithms are generally based on heuristic descriptors such as Spherical Harmonics. More recent advances like ShapeNets tried to voxelize the model and train a deep neural network. On the other hand, MVCNN tries to leverage the power of image classification CNNs, because public image datasets such as ImageNet is much larger than 3d model datasets and state-of-the-art networks on ilsvrc have achieved pretty high precision on classification tasks.</p>
<p>So how about rendering a 3d shape model under different viewpoints and training a 2d CNN with rendered images? Then you can input the rendered views of an unknown model and try to decide its category. This is exactly what we’ll implement in this post. We’ll use multiple rendered images as input and simply do a majority vote to decide the final label for the model.</p>
<p>However, the MVCNN is a bit more complicated in the way it combines multi-view representations. The authors train each view with a different network and introduce a view-pooling layer to combine multiple networks into one, as can be seen on the figure above. View-pooling at its core is simply max-pooling, extracting the largest value at each pixel among all views. More on this topic next time, but let’s first go ahead and implement the simple one :).</p>
<h1 id="Training-MVCNN-Directly-without-View-Pooling"><a href="#Training-MVCNN-Directly-without-View-Pooling" class="headerlink" title="Training MVCNN Directly without View Pooling"></a>Training MVCNN Directly without View Pooling</h1><h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><ul>
<li>Caffe :white_check_mark:</li>
<li>Python2.7(Anaconda2) :white_check_mark:</li>
<li>Scikit-Image :white_check_mark:</li>
</ul>
<h2 id="Data-Preparation"><a href="#Data-Preparation" class="headerlink" title="Data Preparation"></a>Data Preparation</h2><p>You can download the rendered images in their <a href="https://github.com/suhangpro/mvcnn" target="_blank" rel="external">repository</a>. Here I’ll use the modelnet40v2 dataset. On the other hand, you can directly download the models from <a href="http://modelnet.cs.princeton.edu/#" target="_blank" rel="external">Princeton ModelNet</a> and render by yourself if you want better rendering qualities. Although the authors have argued that rendering method is irrelevant with classification precisions.</p>
<p>Please follow the steps described <a href="https://github.com/unclejimbo/mvcnn-caffe/tree/master/modelnet40v2" target="_blank" rel="external">here</a> to preprocess the dataset. Basically all it does is to first pad all images into 256x256, and split a validation set out of training set with ratio 1:9. Then we prepare label text files and compile images into leveldb files to feed into the network. You can sample the inputs if you think the full dataset is too large. I use leveldb rather than lmdb because lmdb seems to have bug with large amount data. If you’re not familiar with this procedure, please check out this <a href="http://caffe.berkeleyvision.org/gathered/examples/imagenet.html" target="_blank" rel="external">tutorial</a>.</p>
<h2 id="Network-Setup"><a href="#Network-Setup" class="headerlink" title="Network Setup"></a>Network Setup</h2><p>Here we’ll try to fine-tune the bvlc-reference-caffenet that caffe provides. The method is pretty much the same as the official <a href="http://caffe.berkeleyvision.org/gathered/examples/finetune_flickr_style.html" target="_blank" rel="external">tutorial on fine-tuning flickr style data</a>. There are a few things to note. First, because we are using the 40 class version of modelnet so the output of this network should be 40. And I’ve fixed the learning rate for all conv layers. Moreover, the latest fc layer’s learning rate is set 5 times higher. Check the prototxt in my <a href="https://github.com/unclejimbo/mvcnn-caffe" target="_blank" rel="external">repo</a> for details.</p>
<h2 id="Go-Ahead-and-Training"><a href="#Go-Ahead-and-Training" class="headerlink" title="Go Ahead and Training"></a>Go Ahead and Training</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">caffe train -solver ./mvcnn_caffenet_simple/solver.prototxt -weights your_caffe_root/models/bvlc_reference_caffenet/bvlc_reference_caffenet.caffemodel -gpu 0</div></pre></td></tr></table></figure>
<p>I’ve tried several parameter setups and the best could give around 72.5% test accuracy. Go play with the parameters by yourself.</p>
<h2 id="Use-Majority-Vote-to-Classify-a-3D-Model"><a href="#Use-Majority-Vote-to-Classify-a-3D-Model" class="headerlink" title="Use Majority Vote to Classify a 3D Model"></a>Use Majority Vote to Classify a 3D Model</h2><p>We’ll now use 80 views as input and take the majority of the predictions as label for this model. The file <a href="https://github.com/unclejimbo/mvcnn-caffe/blob/master/classify_model_simple.py" target="_blank" rel="external">classify_model_simple.py</a> contains the source code for this method:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">import caffe</div><div class="line">import os</div><div class="line">import sys</div><div class="line">import re</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">n_views = 80 # change this if you are not using 80 views per model&quot;</div><div class="line">n_classes = 40 # change this if you are not using 40 class dataset</div><div class="line">model = &quot;./mvcnn_caffenet_simple/deploy.prototxt&quot; # change this to your model defiintion</div><div class="line">weights = &quot;./mvcnn_caffenet_simple/caffenet_train_iter_15000.caffemodel&quot; # change this to your trained model</div><div class="line">mean_file = &quot;./modelnet40v2/mean.binaryproto&quot; # change this to your mean file</div><div class="line">label_name_file = &quot;./modelnet40v2/label_name.txt&quot; # change this to your label_name file</div><div class="line"></div><div class="line">def predict(images, net, transformer):</div><div class="line">    if (len(images) != n_views):</div><div class="line">        sys.exit(&quot;Error: expecting &quot;, n_views, &quot; images in a batch&quot;)</div><div class="line"></div><div class="line">    votes = np.zeros(n_views)</div><div class="line">    for img in images:</div><div class="line">        net.blobs[&apos;data&apos;].data[...] = transformer.preprocess(&apos;data&apos;, img)</div><div class="line">        net.forward()</div><div class="line">        scores = net.blobs[&apos;prob&apos;].data[0].flatten()</div><div class="line">        prediction = np.argmax(scores)</div><div class="line">        votes[prediction] += 1</div><div class="line">    return np.argmax(votes)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    if (len(sys.argv) != 2):</div><div class="line">        sys.exit(&quot;Usage: python classify_model_simple.py /path/to/image_directory/&quot;)</div><div class="line"></div><div class="line">    files = os.listdir(sys.argv[1])</div><div class="line">    if (len(files) % n_views != 0):</div><div class="line">        sys.exit(&quot;Error: num of input images should be divisible by &quot; + str(n_views))</div><div class="line"></div><div class="line">    # Import label-name correspondence</div><div class="line">    label_name = &#123;&#125;</div><div class="line">    with open(label_name_file) as f:</div><div class="line">        for line in f:</div><div class="line">            (label, name) = line.split()</div><div class="line">            label_name[int(label)] = name</div><div class="line"></div><div class="line">    # Net</div><div class="line">    net = caffe.Net(model, weights, caffe.TEST)</div><div class="line"></div><div class="line">    # Convert image mean</div><div class="line">    mean_blob = caffe.proto.caffe_pb2.BlobProto()</div><div class="line">    mean_bin = open(mean_file, &apos;rb&apos;).read()</div><div class="line">    mean_blob.ParseFromString(mean_bin)</div><div class="line">    mean = np.array(caffe.io.blobproto_to_array(mean_blob))</div><div class="line">    # have to manually slice mean size because caffe assume mean size to be the same as input dims,</div><div class="line">    # during training both mean and image sizes could automatically get cropped to network input dims,</div><div class="line">    # however when testing only image size could be cropped automatically by deployment input layer</div><div class="line">    mean = mean[0, :, 14:-15, 14:-15]</div><div class="line"></div><div class="line">    # Transform data</div><div class="line">    transformer = caffe.io.Transformer(&#123;&apos;data&apos;: net.blobs[&apos;data&apos;].data.shape&#125;)</div><div class="line">    transformer.set_transpose(&apos;data&apos;, (2, 0, 1))</div><div class="line">    transformer.set_mean(&apos;data&apos;, mean)</div><div class="line">    transformer.set_raw_scale(&apos;data&apos;, 255)</div><div class="line">    transformer.set_channel_swap(&apos;data&apos;, (2, 1, 0))</div><div class="line"></div><div class="line">    # Load images and predict</div><div class="line">    count = 0;</div><div class="line">    right = 0;</div><div class="line">    for i in range(len(files) / n_views):</div><div class="line">        images = []</div><div class="line">        for j in range(i*n_views, (i+1)*n_views):</div><div class="line">            img = caffe.io.load_image(os.path.join(sys.argv[1], files[j]))</div><div class="line">            images.append(img)</div><div class="line"></div><div class="line">        # Extract label from file name</div><div class="line">        pos = re.search(&quot;\d&quot;, files[j])</div><div class="line">        name = files[j][:pos.start()-1]</div><div class="line">        pred_label = predict(images, net, transformer)</div><div class="line">        pred_name = label_name[int(pred_label)]</div><div class="line">        print(&quot;label: &quot; + name + &quot;, &quot; + &quot;prediction: &quot; + pred_name)</div><div class="line">        count += 1</div><div class="line">        if name == pred_name:</div><div class="line">            right += 1</div><div class="line"></div><div class="line">    print(&quot;Accuracy: &quot; + str(right / float(count)))</div></pre></td></tr></table></figure></p>
<p>The output accuracy is about 78.3%, which is higher than one image classification output.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Great, this simple network does what we’ve expected, although the result is much more inferior to the result achieved in the paper. But this isn’t a surprise because it is image loss rather than model loss that is minimized during training. This also explains the high training error because some views are quite different from others so this adds a lot of noise in our data.</p>
<p>I’ll implement the full mvcnn with view-pooling in the next post, and see if it works better. Stay tuned.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Su H, Maji S, Kalogerakis E, et al. Multi-view convolutional neural networks for 3d shape recognition[C]//Proceedings of the IEEE International Conference on Computer Vision. 2015: 945-953.</p>
<p><a href="http://seiya-kumada.blogspot.jp/2015/10/3d-object-recognition-by-caffe.html" target="_blank" rel="external">http://seiya-kumada.blogspot.jp/2015/10/3d-object-recognition-by-caffe.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;This post is about a paper published in ICCV2015, called &lt;a href=&quot;http://www.cv-foundation.org/openaccess/content_iccv_2015/papers/Su_Multi-View_Convolutional_Neural_ICCV_2015_paper.pdf&quot;&gt;“Multi-view Convolutional Neural Networks for 3D Shape Recognition”&lt;/a&gt;. It describes a method to classify 3d shape models using 2d image classification networks. While the authors have open-sourced their matlab implementation on &lt;a href=&quot;https://github.com/suhangpro/mvcnn&quot;&gt;GitHub&lt;/a&gt;, here I’ll try to implement this network with Caffe.&lt;/p&gt;
&lt;p&gt;In the first half of this two-part blog, I’ll quickly explain the core idea of this paper. After that I’ll try to implement a naive version of this network. While in part II I’ll go through the details on implementing MVCNN as the paper describes.&lt;/p&gt;
&lt;p&gt;The complete codes and scripts in this blog can be found at my &lt;a href=&quot;https://github.com/unclejimbo/mvcnn-caffe&quot;&gt;GitHub repo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/f505454fa4d971db8b85b35ad7cac63795d3eaa0/687474703a2f2f7669732d7777772e63732e756d6173732e6564752f6d76636e6e2f696d616765732f6d76636e6e2e706e67&quot; alt=&quot;&quot;&gt;&lt;br&gt;(&lt;em&gt;The network architecture of MVCNN&lt;/em&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Vision" scheme="https://unclejimbo.github.io/categories/Computer-Vision/"/>
    
    
      <category term="Computer Graphics" scheme="https://unclejimbo.github.io/tags/Computer-Graphics/"/>
    
      <category term="Computer Vision" scheme="https://unclejimbo.github.io/tags/Computer-Vision/"/>
    
      <category term="Deep Learning" scheme="https://unclejimbo.github.io/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Upright Orientation Detection Methods</title>
    <link href="https://unclejimbo.github.io/2016/12/15/Uprigt-Summary/"/>
    <id>https://unclejimbo.github.io/2016/12/15/Uprigt-Summary/</id>
    <published>2016-12-15T14:41:00.000Z</published>
    <updated>2016-12-28T08:46:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Detecting the upright orientation of a 3d shape is a basic yet difficult problem in CG literature. It often serves as a preprocessing step for many geometry processing and shape analysis algorithms such as shape recognition and retrieval.</p>
<p><img src="http://7xllm5.com1.z0.glb.clouddn.com/upright.png" alt="Upright orientation of a chair"></p>
<p>(<em>Upright orientation of a chair</em>)</p>
<a id="more"></a>
<p>For many shapes, there exist natural bases where they naturally stand on so the upright direction should be the normal to that base. However, other shapes (consider a swimmer) may not exhibit a clear standing base so telling this problem could be more subtle.</p>
<p>The following sections summarize existing methods (to the best of my knowledge, they are all of them) and address their issues and limitations.</p>
<h1 id="Known-Methods"><a href="#Known-Methods" class="headerlink" title="Known Methods"></a>Known Methods</h1><ol>
<li>Fu08<ul>
<li>Pipeline:<ul>
<li>computing convex hull</li>
<li>generating hand-crafted features</li>
<li>training on random forest + support vector machine</li>
</ul>
</li>
<li>Data Set: Princeton Shape Benchmark</li>
<li>Precision: 87.5%</li>
<li>Timing: 10.62s (2.13GHz)</li>
</ul>
</li>
<li>Lin12<ul>
<li>Pipeline:<ul>
<li>computing convex hull</li>
<li>generating hand-crafted features</li>
<li>combining scores linearly</li>
</ul>
</li>
<li>Data Set: Princeton Shape Benchmark (120 selected)</li>
<li>Precision: 79%</li>
<li>Timing: 154s (2.33GHz <em>including time to compute best view</em>)</li>
</ul>
</li>
<li>Jin12 &amp; Wang14 (<em>the second method is an improvement on the first one, statistics below accounts for the newer method only</em>)<ul>
<li>Pipeline:<ul>
<li>optimizing against the projection/tensor matrix’s rank</li>
<li>low rank matrix corresponds to a model posed in axis-aligned manner</li>
<li>finding the base from 6 candidate orientations</li>
</ul>
</li>
<li>Data Set: Princeton Shape Benchmark</li>
<li>Precision: about 70%</li>
<li>Timing: 1-2mins (3.30GHz)</li>
</ul>
</li>
<li>Han15<ul>
<li>Pipeline:<ul>
<li>using view selection methods to compute view scores</li>
<li>clustering views whose scores are low as model base candidates</li>
<li>determining upright orientation w.r.t. several hand-crafted features</li>
</ul>
</li>
<li>Data Set: Princeton Shape Benchmark</li>
<li>Precision: 79%</li>
<li>Timing: 7.8s (2.0GHz)</li>
</ul>
</li>
<li>Liu16<ul>
<li>Pipeline:<ul>
<li>voxelizing shapes</li>
<li>training a classification convnet to dispatch input shapes</li>
<li>training a regression convnet for each shape category to find upright orientation</li>
</ul>
</li>
<li>Data Set: ModelNet10</li>
<li>Precision: 90.1% (<em>with convnets clustring</em>)</li>
<li>Timing: 0.15s (3.20GHz)</li>
</ul>
</li>
</ol>
<h1 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h1><ol>
<li>Most man-made models are supposed to stand on its own so computing the convex hull and assigning a hull face as supporting base is appropriate. On the other hand, natural models like human may pose large deformation so there is no clear supporting base. Previous methods failed to solve this conflict.</li>
<li>Method 1 and 5 are still short on training data and the generation power on unseen models is limited.</li>
<li>Other methods based on hand-crafted features and criterions usually give inferior results.</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>Fu H, Cohen-Or D, Dror G, et al. Upright orientation of man-made objects[C]. ACM transactions on graphics (TOG). ACM, 2008, 27(3): 42.</p>
<p>Lin C K, Tai W K. Automatic upright orientation and good view recognition for 3D man-made models[J]. Pattern Recognition, 2012, 45(4): 1524-1530.</p>
<p>Jin Y, Wu Q, Liu L. Unsupervised upright orientation of man-made models[J]. Graphical Models, 2012, 74(4): 99-108.</p>
<p>Wang W, Liu X, Liu L. Upright orientation of 3D shapes via tensor rank minimization[J]. Journal of Mechanical Science and Technology, 2014, 28(7): 2469-2477.</p>
<p>Han HL,Wang WC,Hua M.Getting upright orientation of 3D objects via viewpoint scoring.Ruan Jian Xue Bao/Journal of Software,2015,26(10):2720?2732(in Chinese).</p>
<p>Liu Z, Zhang J, Liu L. Upright orientation of 3D shapes with Convolutional Networks[J]. Graphical Models, 2016, 85: 22-29.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;Detecting the upright orientation of a 3d shape is a basic yet difficult problem in CG literature. It often serves as a preprocessing step for many geometry processing and shape analysis algorithms such as shape recognition and retrieval.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xllm5.com1.z0.glb.clouddn.com/upright.png&quot; alt=&quot;Upright orientation of a chair&quot;&gt;&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;Upright orientation of a chair&lt;/em&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Graphics" scheme="https://unclejimbo.github.io/categories/Computer-Graphics/"/>
    
    
      <category term="Computer Graphics" scheme="https://unclejimbo.github.io/tags/Computer-Graphics/"/>
    
      <category term="Research Log" scheme="https://unclejimbo.github.io/tags/Research-Log/"/>
    
  </entry>
  
</feed>
